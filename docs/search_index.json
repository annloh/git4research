[
["index.html", "Git 4 Research Chapter 1 About 1.1 Note 1.2 Disclaimer", " Git 4 Research Anna Lohmann 2020-05-19 Chapter 1 About This git introduction is meant for researchers. I asume you use git to version control code for data analysis and manuscript preparation. You might even want to use git to collaborate on a research project or share your work with others so they can extend what you have done. Over the past decade I have tried multiple GUIs for git only to find them more confusing than helpful. Hence, this introduction mainly uses git from the command line (Git BASH). Whereever beneficial the built-in GUI tools gitk and git-gui are used. Should you prefer point and click options for using git you need to find yourself another tutorial. (Sorry) https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTU_hDnJ3N1fOjjnu-sn_wJRFk75hO-XVdLs9oQgbalj-AY9O7SmA&amp;s Git-hub will be used for anything related to remote repositories, not because I think it is the best but because it is the only platform I am familiar with and the one predominantely used by my scientific community. 1.1 Note I will be using pointy brackets &lt;&gt; to signify that you have to input whatever your files or names are such as: &lt;your name&gt;, &lt;filename&gt; or &lt;branch name&gt;. The brackets themselves have to be omitted when replacing this placeholder. 1.2 Disclaimer This tutorial is an imperfect mix of my private help file, git presentations I have given and git related questions I repeatedly encounter decorated with git related memes and ressources that I have found funny and/or helpful. Credit for usefulness goes to my amazing husband (???) who has patiently taught me everything I know about git. Any mistakes in this document are a reflection of my inability to correctly apply the wisdom bestowed upon me. The github repository corresponding to this tutorial should NOT be used as an example. Please, do as I say, not as I do ;-) "],
["getting-started.html", "Chapter 2 Getting started 2.1 Installing git 2.2 Get a git-hub account 2.3 Git config", " Chapter 2 Getting started 2.1 Installing git You will need to install git. How to do this is explained here: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git 2.2 Get a git-hub account Get a GitHub account here: https://github.com/join If you are a student or a university researcher you might be elligible for a free pro account. Check out your options here: How to prevent git from demanding your GitHub user name and password all the time can be read here: https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh 2.3 Git config After the installation there are a few customizations that only have to be done once (well once on every computer you work with). They involve telling git your name, your email address, your favourite text editor and linking to your git-hub account. If you are planning on collaborating with people who use a different operating system than you, it is wise to also tell git how to handle line endings. 2.3.1 Setting the configuration information Windows: Rightclick anywhere in a filebrowser and click: “Git BASH HERE” This will open a command line where you will have to enter the following information: $ git config --global user.name \"&lt;Your name&gt;\" $ git config --global user.email \"&lt;your email address&gt;\" The editor to change commit messages is usually whatever you have as a default associated to .txt files you can change it like this $ git config --global core.editor \"&lt;name of my favourite editor&gt;\" Instead of --global you can use --local for a repository or --system for your computer only. This might make sense when you might be commititing changes under an alias e.g. for a collaborator who can’t use git (see section xyx for more details). Alternatively open git gui by typing/ $ git gui in the command line GitGUI will open click the tab “Edit” and then “Options” There are a few more options that are smart to set. You can open the config file in an editor like this: $ git config --global -e --edit 2.3.2 Line endings Windows, Unix and Mac use different line endings. (CRLF = Windows line endings; LF = unix and mac line endings) When your collaborator uses an OS with different line endings it can happen that the diff will indicate that every line of a file was changes even though that is not actially the case. Adding the following line to the git config transforms windows line endings into linux line endings and prevents potential line ending related issues. git config --global core.autocrlf input "],
["basic-background-info-on-git.html", "Chapter 3 Basic background info on Git 3.1 What is Git? 3.2 Why use git? 3.3 Limitations 3.4 Typical text based research file types that work well with git 3.5 Caveat 3.6 Is it for me?", " Chapter 3 Basic background info on Git Many people think of Github as a dropbox for code. While this is relatively far from the truth it is not entirely inacurate. If so then Github is a dropbox on speed. 3.1 What is Git? distributed version-control system most widely used modern version control system in the world most recognized and popular approach to contribute to a project not just for code but for any text-based projects 3.2 Why use git? Version control Keep track of how a project evolved Undo mistakes Maintain alternative versions Test new features without breaking anything Private Collaboration (within lab or with collaborators) Public collaboration (with the research field) Decentralized i.e. you don’t have to be connected to a server to use git (unlike google docs or overleaf) Git encourages the use of a transparant and reviewed workflow 3.3 Limitations Git only works “properly” with text based file-types. Any file can be tracked Git will only be able to display and merge changes for text-based files The git history includes copies of all past versions so larger file types blow up your repository Git is not a backup-system (unless you also upload your repository to a remote server) If you deleted a repository it is gone 3.4 Typical text based research file types that work well with git *.txt (Textfiles) *.R (R File) *.Rmd (R Markdown document) *.csv (Comma delimited value files) *.tex (Latex files) *.bib (Bibliography files) *.sps (SPSS analysis scripts) 3.5 Caveat Depending on when you start managing a project as a git repository collaborators or people on the internet can see every single change you have ever made to the file. Unfortunately, this has been used against people in the past. / While I advocate a transparent research process, you might be taken aback by this level of transparency. There are ways to prevent this. - Only upload a close to final version to github - Collaborate on private repositories and create a new public repository once the project is in a presentable state (It doesn’t actually need to be a new repository. You can also rebase the project to hide past steps) - Write a disclaimer in the readme that the amount of project contribution cannot be inferred from the project history. The option I prefer and recommend is going public from the get go and mainly working on a work-in-progress-branch. Branches on public repositories are also public. The default view, however, is the master branch. Most researchers who are not advanced git users won’t even know about branches and those who don’t won’t bother checking then out. More on branches here 3.6 Is it for me? Do you have several versions of something but no idea what the difference between them is or how they evolved? Do you find yourself copying large sections of code to play with it, try something our wihtout breaking what you already accomplished? Have you ever changed something in multiple parts of your code only to figure out that that was a bad idea and the first aproach was better? Have you ever worked on code with multiple people and have no idea who wrote a specific part? "],
["the-command-line.html", "Chapter 4 The command line 4.1 Open Git BASH 4.2 General notes regarding the command line 4.3 Other useful command line knowledge:", " Chapter 4 The command line The command line (aka Git BASH or console) is how we tell git what to do. If you are familiar with using a command line in LINUX this one will be just the same. You can change directories, list files and so on. In this into I will not assume that you have any knowlege of how to use the commandline (i.e. change directories and such) so we will always open it right in the folder we want to use it. 4.1 Open Git BASH Use your file explorer to navigate to the folder you want to version control with git. Rightclick anywhere in a filebrowser and click “Git BASH HERE” This will open a command line where you will have to enter the the commands that you find in this introduction. 4.2 General notes regarding the command line The following should be kept in mind when usind the command line to not go completely crazy in the process: - Capitalization matters - Spacing matters - Some shortcuts like Ctrl+c or Ctrl+v won’t work. You can use the right mouse key instead. - The tab key is your best friend as it will auto-complete or partially autocomplete anything for you which greatly reduces the risk for typos - The up-key is your second best friend. Pressing the up-key will automatically input the last command used. This is especially useful if you got an error and just need to slightly adjust the previous input. 4.3 Other useful command line knowledge: touch filename.txt creates a new file &amp; at the end of a line will make sure you can keep using the command line without closing whatever you opened "],
["basic-concepts.html", "Chapter 5 Basic concepts 5.1 Working directory 5.2 Staging area 5.3 History 5.4 Remote 5.5 Stash", " Chapter 5 Basic concepts The following figure shows an overview of the git logic. If you understand what is going on there and how the individual parts relate to each other using the git verbs you are good to go. If you understand these basic concepts you are well equipped to conquer git. 5.1 Working directory 5.2 Staging area 5.3 History 5.4 Remote 5.5 Stash "],
["talking-to-git.html", "Chapter 6 Talking to git 6.1 Getting help", " Chapter 6 Talking to git Your main way of communicating with git is the command line. Every interaction with git works in the same way. Determine which repository you are currently working with. Open Git bash in the folder that contains that repository. Tell git what to do. Step 3 always consists of typing git &lt;verb&gt; and hitting enter. Often the verb is followed by more or less obscure other things that specify the way in which git should do the verb. Examples: git commit -m '&lt;commit message&gt;' git add &lt;hallo_world.txt&gt; git checkout -b git clean -n If you are familiar with the Linux command line these letters will probably make sense to you. If you are not you can either live with the fact, that what you are typing makes little obvious sense or read up on it here: 6.1 Getting help If you forgot the precise command that you wanted to use you can of course google it. But git also comes with a build in help. git help &lt;verb&gt; or git &lt;verb&gt; --help I’d generally recommend to google things until you feel halfway confident as the git help is not exactly written for beginners. In this introduction we will cover three more ways to interact with git. They will be introduced because they make your life easier for certain tasks plus they give you an additional sense of control by visually confirming what has happend. "],
["initiating-a-repository.html", "Chapter 7 Initiating a repository 7.1 Clone existing repository 7.2 Fork existing repository 7.3 Create a new local repository", " Chapter 7 Initiating a repository We will introduce three simple ways to version control your work with git. There are more but these should get you started: 7.1 Clone existing repository This is the easiest way to start a project that you also want to maintain on github or that you want to collaborate on. You go to a repository on github and clone it. This can either be an existing repository that a colleague added you to as a collaborator or you can create a new empty repository on github to start a project. Here the step by step instructions: 7.1.1 !Caveat Do not clone a remote repository that you do not have writing access to. What you should do instead is fork it. 7.2 Fork existing repository https://dzone.com/storage/temp/8374694-forked.png 7.3 Create a new local repository If you want to only track your work locally you can create a new repository like this: $ git init "],
["beyond-the-command-line.html", "Chapter 8 Beyond the command line 8.1 gitk 8.2 gitGUI 8.3 kdiff3", " Chapter 8 Beyond the command line Making life easier 8.1 gitk Gitk is a handy tool for the occasional sanity check. It shows you the commit history and all the important information relating to the individual commits. It is the easiest way to quickly check things. You can open gitk by typing gitk --all &amp; This will make what you see a little prettier as it sorts by date-order gitk --all --date-order &amp; This will open a new window with gitk. The &amp; at the end of the line will allow you to keep using the command line while having the gitk window open. gitk allows you to get a good overview of your repository history. Feel free to look around and see what happens if you click certain things. 8.2 gitGUI Though I argued againt the use of a GUI for git occasionally it can be useful to have one. Git actually comes with a built in GUI that can make some operations smoother. 8.3 kdiff3 kdiff 3 is a difftool that needs to be installed separately from git. After installing it you will furthermore have to tell git that you would like it to use kdiff3 as a difftool. A difftool gives you a nice visual representation of the changes between commits. It furthermore has some nice options to streamline merging. "],
["git-commands-for-the-local-repository.html", "Chapter 9 Git commands for the local repository", " Chapter 9 Git commands for the local repository $ git init will create a .git folder which is hidden. This initializes a repository. $ git add will put files in a staging area $ git status will show differences between staging area and working tree $ git commit will take everything that is in the staging area and put in in the local repository $ git clean -f deletes all untracked files "],
["git-commands-for-the-remote-repository.html", "Chapter 10 Git commands for the remote repository", " Chapter 10 Git commands for the remote repository $ git push will take your commit and take it to a remote repository (e.g. github) $ git fetch will get the latest changes from a remote repository (but not integrate them i.e. merge them with your local files) $ git clone will copy a remote repository to your local folder One of the standard commands covered in all git intros is $ git pull. There should not ever be a reason to use it but a lot of reasons against it so its use is not recommended. $ git pull is equivalent to $ git fetch plus $ git merge. The only reason to ever use $git pull is if there are changes on the remote that you do not have locally. (For example from a collaborator, or a different computer that you sync via the remote.) If there is something on the remote that you don’t have in your local repository there are three different scenarios (1) You want the changes. (2) You don’t want the changes. (3) You want part of the changes. Only the first option is acchieved by $ git pull. The more likely scenario is you might want to check out the changes and then decide on (1),(2) or (3). Hence, first $git fetch and then (maybe) `$ git merge $ "],
["commits.html", "Chapter 11 Commits 11.1 What is a commit? 11.2 Commit messages 11.3 When to commit?", " Chapter 11 Commits 11.1 What is a commit? If you decide to commit your staged files git will take a snapshot of the new status and add it to the repository. This snapshot will come with a unique sha1 hash. This unique hash can be used to refer to this snapshot in the future. Technically, a commit refers to all the file content, plus the history up to that point, plus all the metadata, which is represented by the hash created from all of this. When people taking about the “content of a commit” oder “reverting the commit” what they actually mean are the changes introduced by this commit so the diff to the previous commit. $ git commit Opens an editor and lets you enter your commit message The message should not be longer than 50 character and summarize what the commit does. This is the first line in the editor. In a new line more information can be added that provides more details. The open editor will also show a ton of information preceden by a #. This information is not part of the commit message. A shortcut, that lets you enter the commit message in the command line is $ git commit -m \"&lt;Add commit message here&gt;\" 11.2 Commit messages https://imgs.xkcd.com/comics/git_commit_2x.png 11.2.1 Content of Commit messages There are a few simple rules that you should follow when writing commit messages. https://chris.beams.io/posts/git-commit/ 11.2.2 Styling Commit messages You can decorate your commit messages with emojis. An overview can be found here: https://www.webfx.com/tools/emoji-cheat-sheet/ While some emojis are really useful and ease communication others might be less useful Some fruthermore have a really long definiton which takes up valuable space in the commit message. If you would like to use emojis in your commit messages decide on a set of icons and their use together with your collaborators. Here a few ideas of how they can be used: Emoji Emoji code Description Change visible to user Change to meaning of production code :star: :star: New / changed feature :heavy_check_mark: :heavy_check_mark: :bug: :bug: General bugfix :heavy_check_mark: :heavy_check_mark: :lock: :lock: Security feature / bugfix :heavy_check_mark: :heavy_check_mark: :recycle: :recycle: General refactoring :x: :heavy_check_mark: :zap: :zap: Performance- / memory-related refactoring :x: :heavy_check_mark: :art: :art: Formatting, white space, renaming variables etc :x: :x: :pencil: :pencil: Documentation, code comments :x: :x: :mag: :mag: Writing, refactoring, fixing automated tests :x: :x: :wrench: :wrench: Build scripts, CI, gitignore, other chore :x: :x: 11.3 When to commit? A difficult decision is at what point to commit. What amount of changes define a useful set to commit? First of all the change introduced by a commit should be logical and coherent. So changing three typos adding a comment and defining a new function is neither logical nor coherent. These changes should be in different commmits. On the other hand commiting frequently, i.e. keeping the commits small is beneficial for collaboration (less time for others to change stuff creating merge conflics) and also good from a backup perspective. Furthermore, it is easier to undo small things than large things. However, the amount of things changed does not have to be one. If you, for example, decide to use a different estimator and therefore have to change a lot of code that could still be a coherent set of changes. “Use estimator abc instead of estimator xyz”. More information about the size of a commit can be found here: https://curiousprogrammer.io/blog/why-i-create-atomic-commits-in-git "],
["branches.html", "Chapter 12 Branching 12.1 Creating a new branch 12.2 Switching branches 12.3 Fetching changes after pull request", " Chapter 12 Branching https://i.imgur.com/YG8In8X.png 12.1 Creating a new branch $ git branch &lt;new branch&gt; creates a new branch but does not check it out (i.e. does not switch to it) Create a new branch and imediately check it out $ git checkout -b &lt;new-branch&gt; This will get you a new local branch. It is however not automatically availible on the remote. This can be acchieved as following: $ git push origin &lt;new-branch&gt; 12.2 Switching branches To continue working on a different bracnch you have to switch branches by checking out the branch you would like to work on. $ git checkout &lt;branchname you want to work on&gt; Careful! As always with checking out, make sure to stage or stash your changes, otherwise you lose work. Creating a new branch locally does not result in the remote having the same branch (and the other way around). 12.3 Fetching changes after pull request $ git fetch --prune Deletes references to remote branches which have been deleted on the server "],
["merging.html", "Chapter 13 Merging", " Chapter 13 Merging $ git merge --ff-only Gives a warning if the merge is not a fast-forward merge and does not go through with it $ git merge --no-ff Does fast-forward but creates a merge commit "],
["problem-solving.html", "Chapter 14 Problem solving 14.1 You don’t like your changes 14.2 Push against resistence 14.3 You ammended after pushing to the remote", " Chapter 14 Problem solving 14.1 You don’t like your changes https://meme-arsenal.com/create/meme/628437 14.2 Push against resistence https://i.imgflip.com/lrihf.jpg 14.3 You ammended after pushing to the remote Git will not let you push after ammending because the ammend changed the commit and it does not match the remote one anymore. Git hence recommends that you pull first. That is not what you want because you have just changed that last commit with ammend. You will hence have to force the push. $ git push --force-with-lease This way of forcing the push is preferred over $ git push -f because the with-lease will check whether there are any additional changes on the remote that you had not fetched yet. https://pbs.twimg.com/media/B093CwRCQAEwnD4?format=jpg&amp;name=large "],
["pull-requests.html", "Chapter 15 Pull requests", " Chapter 15 Pull requests A pull request (which should actually be called a merge request) is a commit that a collaborator suggests should be merged. Git-hub offers special features for pull requests that make it easy to review and annotate the suggested code changes. It is possible to add additional commits to a oull request if it has not been accepted yet. "],
["diff.html", "Chapter 16 Diff 16.1 Comparing current changes 16.2 Comparing arbitrary commits 16.3 Difftool (kdiff3)", " Chapter 16 Diff 16.1 Comparing current changes $ git diff show differences between the working directory and the index $ git diff --cached show difference between the index and the most recent commit $ git diff HEAD show differences beween your working directory and the most recent commit All of the commands aboven can be combined with a filename to limit it to the diff of that file, i.e. $ git diff &lt;filename&gt; 16.2 Comparing arbitrary commits $ git diff &lt;partial hash&gt;..&lt;partial hash&gt; $ git diff &lt;branch1&gt;..&lt;branch2&gt; This can also be combined with a filename: $ git diff &lt;branch1&gt;..&lt;branch2&gt; &lt;filename&gt; How to read a diff is nicely explained here: https://www.git-tower.com/learn/git/ebook/en/command-line/advanced-topics/diffs 16.3 Difftool (kdiff3) A difftool is a program that facilitates viewing a diff. If you replace the diff in the $ git diff command by difftool the difftool will open in a new window and show the requested diff. Adding a &amp; to the end of the line allows you to keep using the commandline with the difftool open. git difftool &amp; opens the predefined difftool (in my case “kdiff3”) shows index on the left and working directory on the right git difftool HEAD &amp; show differences beween your working directory and the most recent commit most recent commit is on the left and working directory on the right "],
["blame.html", "Chapter 17 Blame 17.1 Figuring our who is responsible", " Chapter 17 Blame https://img.devrant.com/devrant/rant/r_811491_uTXmv.jpg 17.1 Figuring our who is responsible $ git blame "],
["git-workflow.html", "Chapter 18 Git workflow 18.1 Feature branches 18.2 Pull requests 18.3 Tipps to make life with git easier", " Chapter 18 Git workflow https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf 18.1 Feature branches 18.2 Pull requests When you have done some work on a feature branch and would like to incorporate those changes into the master brach it is good practice to send a pull request (rather then push to the master branch). A pull request is a message that lets your collaborators now that a substantial part is ready and can be reviewed. This can initiate a conversation about the suggested changes. More on pull requests here: https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests#draft-pull-requests 18.3 Tipps to make life with git easier submit frequently keep lines short (i.e. less than 80 characters when coding, one sentence when wiring in latex) "],
["collaboration-hacks.html", "Chapter 19 Collaboration Hacks 19.1 Hack 1: Dropbox (or other cloud storage) 19.2 Hack 2: Overleaf (For latex)", " Chapter 19 Collaboration Hacks What if my collaborators can’t use git? 19.1 Hack 1: Dropbox (or other cloud storage) Create a git repository for them in a cloud storage. Set the name and emailadress to match the collaborator. Create a branch for them to work on and make sure that branch is checked out. When they are done working send a pull request for their branch. Or merely look at the diff and decide what you want to keep. Advantage: You are in full control of what can be done to that repository since you have full access. Should you have found some mistakes you can update your collaborators version. Disadvantage: Potentially messy. 19.2 Hack 2: Overleaf (For latex) Overleaf can be set up to push to github. Furthermore, you can clone the whole project. Advantage: Easy to use. Disadvantage: Hideous commit messages. If your collaborator forgets to pull things get really messy. "],
["other-peoples-code.html", "Chapter 20 Other peoples code", " Chapter 20 Other peoples code You have found something on github (or elsewhere on the internet) and would like to use it as a template? Great! Answer the following questions to ensure proper acknowledgement of your sources: 20.0.1 Are you improving a product and would the original author benefit from your improvements? Fork the repository. You will know have a replica of the original (same name, complete history). However, this is now your personal copy. It will show the original authors as contributors and everyone can see when and where you started modifying the original. As git still knows the original history you can make changes to the repository and send a pull request to the original authors inviting them to incorporate your changes. See here for more info on that: https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request-from-a-fork 20.0.2 Are you just stealing some code to get you started? Download the files and start your own repository. The complete history is now gone. It is not apparent that other people have been working on this in the past. For reasons of transparency and acknowledgement do the following: In your initial commit message add the url from where you got the code and the sha-1 hash which indicates the exact commit that served as the source. You can additionally mention the source in the README.Md. Saving the hash of the original source also allowes you to obtain updates that the original author might add in the future. (We will not cover how to do this in this intro.) "],
["gitignore.html", "Chapter 21 .gitignore 21.1 Create .gitignore 21.2 Ignore folders 21.3 Ignore specific files 21.4 Ignore specific filetype 21.5 Ignore files with specified string 21.6 Comments 21.7 What should go in the .gitignore?", " Chapter 21 .gitignore Gitignore is a file which tells git which files to ignore i.e. which files should not be added to the repository. The gitignore can contain specific files. Folders that should be ignored. Files with specific endings or partial file names. 21.1 Create .gitignore Enter touch .gitignore or create a textfile and rename it to .gitignore (no .txt ending just this) 21.2 Ignore folders /foldername/ - First / indicates - Second / 21.3 Ignore specific files filename.ending 21.4 Ignore specific filetype *.pdf 21.5 Ignore files with specified string 21.6 Comments Any line starting with a # will be treated as a comment 21.7 What should go in the .gitignore? temporary files output files "],
["ressources.html", "Chapter 22 Ressources 22.1 Pro Git 22.2 YouTube videos 22.3 Troubleshooting 22.4 Cheat Sheet 22.5 More Info on specific topics 22.6 Atomic Commits 22.7 Commit messages", " Chapter 22 Ressources 22.1 Pro Git This free ebook is an excellent ressource for anything git related and very well explained: https://git-scm.com/book/en/v2 22.2 YouTube videos This tutorial by Cory Scafer covers all the basics https://www.youtube.com/watch?v=HVsySz-h9r4 Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits https://www.youtube.com/watch?v=FdZecVxzJbk I have also enjoyed the three part YouTube git series by David Mahler with great examples. It has a slightly higher speed than the above, for more impatient folks. https://www.youtube.com/watch?v=uR6G2v_WsRA https://www.youtube.com/watch?v=FyAAIHHClqI https://www.youtube.com/watch?v=Gg4bLk8cGNo&amp;t=85s Both are based on the ProGit book and cover the most important concepts in a very approachable way. 22.3 Troubleshooting Here are a few ressources about dealing with common problems: https://ohshitgit.com/ 22.4 Cheat Sheet https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf 22.5 More Info on specific topics 22.6 Atomic Commits https://curiousprogrammer.io/blog/why-i-create-atomic-commits-in-git 22.7 Commit messages https://chris.beams.io/posts/git-commit/ 22.7.1 Rebasing https://www.atlassian.com/git/tutorials/merging-vs-rebasing https://www.youtube.com/watch?v=6nolZKpiG_w 22.7.2 Stashing https://www.youtube.com/watch?v=KLEDKgMmbBI "]
]
